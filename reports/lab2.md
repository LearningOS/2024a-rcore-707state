# 编程作业

## 重写sys_get_time和sys_task_info

引入虚存机制后，原来内核的 sys_get_time 和 sys_task_info 函数实现就无效了。请你重写这个函数，恢复其正常功能。

### 思路

原本的sys_get_time的实现如下：

```rust
/// get time with second and microsecond
pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -> isize {
    trace!("kernel: sys_get_time");
    increase_syscall_number(SYSCALL_GET_TIME);
    let us = get_time_us();
    unsafe {
        *ts = TimeVal {
            sec: us / 1_000_000,
            usec: us % 1_000_000,
        };
    }
    0
}
```
原本的sys_task_info实现如下：
```rust
pub fn sys_task_info(ti: *mut TaskInfo) -> isize {
    trace!("kernel: sys_task_info");
    increase_syscall_number(SYSCALL_TASK_INFO);
    if ti.is_null() {
        return -1;
    }
    let current_task = TASK_MANAGER.get_current_task();
    unsafe {
        (*ti).status = current_task.task_status;
        (*ti).syscall_times = current_task.syscall_times;
        (*ti).time = get_time_ms();
    };
    0
}
```

### 思路

先检查sys_get_time传入的指针是否有权限写入这个地址，因此要对ts的地址进行地址转换。之后过程相同。

sys_mmap中传入的第一个参数也是一个地址，只是传入的形式是usize。

# 思考题

SV39 页表项的组成与标志位作用

在 RISC-V 架构的 SV39（39-bit Virtual Addressing Scheme）页表中，每个 页表项 (PTE) 是一个 64 位的结构，主要包含以下内容：
页表项 (PTE) 的组成：

    PPN (Physical Page Number)：44 位
    指向物理页的起始地址。系统用这部分来找到实际的物理页。

    V (Valid)：第 0 位
    指示此 PTE 是否有效。无效时访问该页将导致缺页异常。

    R (Read)：第 1 位
    是否允许读取该页。

    W (Write)：第 2 位
    是否允许写入该页。

    X (Execute)：第 3 位
    是否允许执行该页上的代码。

    U (User)：第 4 位
    标志该页是否用户态可访问。若为 0，则该页只允许在内核态访问。

    G (Global)：第 5 位
    表示此页是否为全局页，所有进程共享。若设置为 1，则 TLB 不会为不同的地址空间刷新该页的缓存。

    A (Accessed)：第 6 位
    由硬件设置，表示该页是否被访问过。

    D (Dirty)：第 7 位
    由硬件设置，表示该页是否被写入过。

标志位的作用：

    V 位用于判断页表项是否有效。如果无效，访问该页将触发缺页异常。
    R/W/X 控制内存页的访问权限，分别对应读、写和执行权限。
    U 位防止用户态代码访问内核专用页，增强系统安全性。
    A/D 位用于优化换页算法，帮助操作系统判断页面是否活跃。

缺页异常的可能原因与相关寄存器：
哪些异常可能是缺页导致的？

    Page Fault (缺页错误)：
        访问一个 不存在 或 无效 的虚拟页。
        尝试对页表中设置了无访问权限的页面进行非法访问（如写入只读页）。

    Invalid Access：
        用户态程序尝试访问内核态页。

    Swap 回页错误：
        访问已被换出到磁盘的页面时。

缺页时的相关寄存器：

    satp：存放当前页表的基地址，用于页表切换。
    stval：存放导致异常的虚拟地址。
    scause：记录异常的原因（如缺页异常）。
    sstatus：记录处理器的状态。

Lazy 策略的好处：

    减少不必要的内存分配：避免加载和映射未实际使用的内存页。
    节省启动时间：程序启动时无需等待所有内存段加载完毕。
    提高内存利用率：只有真正使用的部分才会占用内存。

SV39 页表占用内存的估算：
10G 连续内存的页表开销：

    页大小：4 KB
    页表项数量：10G / 4K = 2.5M 页
    每个 PTE 占 8 字节，所以页表的总开销大致为：
    2.5M × 8 = 20 MB

Lazy 策略实现与缺页处理：

    Lazy 策略：
        初始化时不实际分配内存，只保存虚拟页的映射信息。
        只有在访问某个虚拟页时，触发缺页异常，再真正分配和映射内存。

    缺页处理流程：
        捕获缺页异常，读取异常地址（stval）。
        判断访问权限是否合法。
        分配对应的物理页，更新页表项。
        重新执行导致缺页的指令。

Swap 策略与 PTE 表现：

    当某个页面被换出到磁盘时：
        PTE 的 V 位被清 0，表示该页无效。
        可以在 PTE 中记录页在磁盘中的位置，用于回页时参考。

双页表与单页表的区别：
单页表的实现：

    用户态和内核态共享同一页表，只是控制访问权限。
    在内核态访问用户页时，也必须在页表中有对应映射。

如何更换页表？

    修改 satp 寄存器来指向新的页表。
    刷新 TLB 缓存，确保页表修改生效。

如何控制用户态无法访问内核页面？

    在页表中设置内核页的 U 位为 0，用户态无法访问这些页。

单页表的优势：

    减少内存开销：仅需要维护一张页表。
    切换开销低：不需要频繁更换页表。

双页表的页表切换时机：

    在系统调用或中断时，需要切换到内核页表。
    返回用户态时，再切换回用户页表。

选择何时更换页表：

    若设计单页表系统，建议在 上下文切换 时更换页表，以确保每个进程拥有独立的地址空间，避免互相干扰。



# 荣誉准则



1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
